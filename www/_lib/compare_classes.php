<?php

//============================================================================
//
// compare_classes.php
// -------------------
//
// Classes for server comparision
//
// Part of s-audit. (c) 2011 SearchNet Ltd
//  see http://snltd.co.uk/s-audit for licensing and documentation
//
//============================================================================

class compareListPage extends audPage {

	// This is the default landing page for the compare servers page

    protected $no_class_link = true;
		// There's no "this class" documentation link

	protected $group;

	protected $ff;
		// Path to friends file

	protected $map;
	
	public function __construct($title, $map)
	{
		if (!isset($_GET["g"]))
			die("no group");

		$this->group = $_GET["g"];
		$this->map = $map;

		$this->ff = AUDIT_DIR . "/$this->group/friends.txt";

		// Expand the map. We need all the local zone names, so create the
		// servers[] array in the map, just like GetServers normally does

		foreach($map->map as $global=>$file) {
			$this->map->servers[$global] =
			array_slice(array_unique(preg_grep("/^hostname=/",
			file($file))), 1);
		}

		parent::__construct($title, false);
	}

	public function ff_list()
	{
		// Say whether or not we're using a friends file. If we are, display
		// the list

		$ff_link = "<a href=\"" . DOC_URL .
		"/04_extras/friends.php\">friends file</a>";

		$ret = "\n\n<p class=\"center\">";
		
		if (file_exists($this->ff)) {

			$friends = file($this->ff);

			// Read in the friends file and make a key=>value array of the
			// pairs inside it

			foreach($friends as $row) {

				if (preg_match("/^\w/", $row)) {
					$a = preg_split("/\s+/", $row);

					if (count($a) == 3) $pairs[$a[0]] = $a[1];
				}

			}

		    $ret .= "The following server comparisons are defined in the
			$ff_link at <tt>$this->ff</tt>.</p>";

			$ret .= "\n\n<ul>";

			foreach($pairs as $key=>$val) {

				// Only display pairs which both exist in the map

				if ($this->map->has_data($key) &&
					$this->map->has_data($val))
						$ret .= "\n  <li><a href=\"$_SERVER[PHP_SELF]?g="
						.  $this->group . "&amp;z1=$key&amp;z2=$val\">"
						."$key and $val</a></li>";
			}

			$ret .= "\n</ul>";
		}
		else
			$ret .= "You do not have a $ff_link for this audit group.</p>";

		return $ret . new compareCyc($this->map->list_all(), $this->group);
	}

}

//----------------------------------------------------------------------------

class compareCyc {

	// The dual cycle gadget on the server comparison page

	private $html;
		// The HTML generated by the constructor

    public function __construct($z_list, $group, $z1 = false, $z2 = false)
    {
		// This is the bar at the bottom of the screen that lets you choose
		// the servers to compare from cycle gadgets.
		
		$h = new html;

        $this->html = "\n<div class=\"center\">"
        . $h->dialog_form($_SERVER["PHP_SELF"])
        . $h->dialog_submit("c", "compare")
        . $h->dialog_cycle("z1", $z_list, $z1, false) . " with "
        . $h->dialog_cycle("z2", $z_list, $z2, false)
		. $h->dialog_hidden("g", $group)
        . "</form>\n</div>";
    }

	public function __toString() 
	{
		return $this->html;
	}

}

//----------------------------------------------------------------------------

class comparePage extends audPage {

    protected $no_class_link = true;
		// There's no "this class" documentation link

}

//----------------------------------------------------------------------------

class compareView extends HostGrid {
	
	// This class groups together all the functions needed to compare two
	// servers, and display the results of that comparison. It works like
	// the serverView class does for single server pages.
	
	// We have to extend the HostGrid because we use its methods to display
	// data

    private $a;
    private $b;
        // The two servers on which we're doing an a/b comparison

	private $classes;
		// Audit classes we're going to compare

	/*
    protected $fields;
    protected $rows;

    protected $pairs = array(
        "packages" => "package",
        "patches" => "patch"
    );
	*/

    public function __construct($data, $map)
    {
		// set up some variables 

		$this->map = $map;

		//pr($data);

		// Populate the $fields array with the hostnames of the servers to
		// compare and get a list of classes. Servers should always have the
		// same classes, but make sure we get everything anyway.

		$classes = array();

		// create $this->data, which puts the class data for each machine in
		// the same level of the data structure
		//
		// [class] -> [server_a]
		//            [server_b]

		foreach($data as $host=>$h_data) {
			$this->fields[] = $host;

			foreach($h_data as $class=>$c_data) {

				$this->data[$class][$host] = $c_data;

				if (!in_array($class, $classes))
					$classes[] = $class;
			}

		}

		$this->classes = $classes;
    }

    public function show_grid()
    {
		// The grid in this case is a list of tables, one for each audit
		// type. Each table is created by its own class

        $ret = false;

        foreach($this->classes as $type) {

            $class = (class_exists("compare$type"))
				? "compare$type"
                : "compareGeneric";

			// Call the class with its name, the data for servers, and the
			// map

            $ret .= new $class($type, $this->data[$type], $this->map);
        }

        return $ret;
    }

}

class compareGeneric extends HostGrid {

	private $hosts;

	protected $cols;
		// columns, excluding the key - size of the hosts array

	private $html;

	protected $no_colour = array("hostname", "audit completed");

	protected $no_compare = array();

	private $width = "40%";
	private $colwidth;
		// the % width of each column in the comparison table

	public function __construct($type, $data, $map)
	{
		$this->map = $map;

		// Get the hostnames and all the rows we're going to compare

		$this->hosts = array_keys($data);
		$this->cols = count($this->hosts);

		// This is slow and messy, but I can't think of a better way to do
		// it right now

		$rows = array();

		foreach($this->hosts as $host) {
			
			foreach($data[$host] as $key=>$value) {

				if (!in_array($key, $rows))
					$rows[] = $key;
			}

		}

		$this->data = $data;
		$this->rows = $rows;
		$this->colwidth = round(100 / $this->cols) . "%";

		$this->html = "\n\n<table align=\"center\" width=\"$this->width\">"
		. "\n<tr><td><h1>$type audit comparison</h1></td></tr>\n</table>\n"
		. $this->compare_class();
	}

	protected function compare_class()
	{
		// Print the comparison tables for the class

		$ret = "\n\n<table border=3 class=\"audit\" align=\"center\""
		. " width=\"$this->width\">\n";

		foreach($this->rows as $row) {
			$method = "compare_$row";

			if (in_array($row, $this->no_compare)) {
				$rowdat = "don't compare";
				continue;
			}

			elseif(method_exists($this, $method)) {
				$rowdat = $this->$method($this->get_cmp_data($row));
			}
			else
				$rowdat = $this->compare_generic($this->get_cmp_data($row),
				$row);

			// We colour the left-hand column red or green, depending on
			// whether we found a difference or not. First, though, we work
			// out all the host rows 

			$d = "";
			$keycol = "green";

			foreach($rowdat as $line) {

				if ($d != "")
					$d .= "\n<tr>";

				if (isset($line["all"]))
					$d .= new Cell($line["all"], false, false, false,
					$this->cols);
				else {
					$d .= new Cell($line["a"], $line["ca"], false,
					$this->colwidth) . new Cell($line["b"], $line["cb"], false,
					$this->colwidth);
					$keycol = "red";
				}

				$d .= "</tr>";
			}

			$ret .= "\n<tr><td class=\"solid$keycol\" ";
			
			if (count($rowdat) > 1)
				$ret .= "rowspan=\"" . count($rowdat) . "\"";
			
			$ret .= ">$row</td>$d";
		}

		return $ret . "\n</table>";
	}

	protected function get_cmp_data($row)
	{
		// Get the "row" data for all hosts, and put it in an array. For
		// now, this only operates on two hosts. May increase later, which
		// is why it's in a separate method

		$ret = array();

		foreach($this->hosts as $host) {

			$ret[] = isset($this->data[$host][$row])
				? $this->data[$host][$row]
				: array(false);
		}

		return $ret;
	}

	protected function compare_generic($data, $row)
	{
		// First find things that are the same

		$ret = array();

		foreach(array_intersect($data[0], $data[1]) as $match) {
			$ret[] = array("all" => $match, "ca" => false, "cb" => false);
		}

		// Things that are different. We need to do this both ways

		// Now get the differences looking both ways. We do the
		// array_values() call so the indicies start at zero

		$ma = array_values(array_diff($data[0], $data[1]));
		$mb = array_values(array_diff($data[1], $data[0]));

		// We have to make the arrays the same size
		
		$sa = $diffs = count($ma);
		$sb = count($mb);

		if ($sa > $sb)
			$mb = array_pad($mb, $sa, false);
		elseif ($sb > $sa) {
			$ma = array_pad($ma, $sa, false);
			$diffs = $sb;
		}
		
		for($i = 0; $i < $diffs; $i++) {
			$tmp_arr = array("a" => $ma[$i], "b" => $mb[$i]);
        
			if (in_array($row, $this->no_colour)) {
				$tmp_arr["ca"] = $tmp_arr["cb"] = false;
			}
			else {

				if ($this->safe_compare($ma[$i], $mb[$i])) {
					$tmp_arr["ca"] = "ver_l";
					$tmp_arr["cb"] = "ver_o";
				}
				else {
					$tmp_arr["ca"] = "ver_o";
					$tmp_arr["cb"] = "ver_l";
				}
				
			}

			$ret[] = $tmp_arr;
		}

		return $ret;
	}

	public function safe_compare($a, $b)
	{
		// If you're comparing version numbers and you hit, say, 2.2.4 and
		// 2.2.11, a normal >/< type comparison will tell you 2.2.4 is the
		// later version, which it plainly isn't. This functon uses PHP's
		// natural sort algorithm to get the higher version. It also ignores
		// anything that's not part of the version string. (i.e. anything
		// after the first space)
		
		// returns true if a > b
		// returns false otherwise

		$ea = preg_replace("/ .*$/", "", $a);
		$eb = preg_replace("/ .*$/", "", $b);

		$arr = array($a, $b);
		natsort($arr);

		return (current($arr) == $a) ? false : true;
	}

	public function __toString()
	{
		return $this->html;
	}

}

class comparePlatform extends compareGeneric {

	protected $no_colour = array("hostname", "audit completed", "hardware",
	"virtualization", "serial number", "ALOM IP", "CPU", "card", "memory",
	"storage");

}

class compareOS extends compareGeneric {

	protected $no_colour = array("hostname", "audit completed", "hostid",
	"local zone");
}

class compareNet extends compareGeneric {

	protected $no_colour = array("hostname", "audit completed", "NTP",
	"name service", "DNS server", "port", "route", "NIC");
}

/*
    public function grid_header()
    {
		// We override the HardwareGrid function because we want to specify
		// column widths

        return "\n<tr><td></td><th width=\"40%\">". $this->fields[0]
		. "</th><th width=\"40%\">". $this->fields[1] . "</th></tr>";
    }

    public function grid_body()
    {
		// Loop through each audit class. The constructor in the class we
		// call will create the table rows

		$ret = "";

		foreach($this->sa as $type=>$data) {
			$class = "compare$type";
	
			if (!class_exists($class))
				$class = "compareGeneric";
				
			//pr($data);

			$ret .= new $class($this->map, $data, $this->sb[$type]);
		}

		return $ret;
    }

	protected function grid_key()
	{
		// We don't currently have a key
		
		return false;
	}

}

//----------------------------------------------------------------------------

class compareGeneric extends HostGrid {

	// This works like singleGeneric in single server views. Each audit
	// class has a compareClass class which extends this one. They do all
	// the work

	protected $da;
	protected $db;
		// Data for zone A and zone B
	
	protected $html;
		// HTML we return

	protected $omit = array("hostname", "audit completed");
		// These fields are not shown
	
	protected $no_col = array();

	public function __construct($map, $da, $db)
	{
		// First off get a list of rows. There may be elements in $da that
		// aren't in $db and vice versa

		$rows = array_unique(array_merge(array_keys($da), array_keys($db)));

		$this->da = $da;
		$this->db = $db;

		$this->cols = new Colours;

		$this->map = $map;

		foreach($rows as $row) {
			$this->html .= $this->compare_row($row);
		}

	}

    public function compare_row($row)
    {
		// This function does most of the work in comparing servers. It
		// is fed in the name of the data to compare ($row -- it's the
		// left-hand column label on the grid, and it's also the key of the
		// arrays we're comparing). If looks to see if a dedicated method
		// exists for comparing the data, and if not, it does the comparison
		// itself.  Watch out for multiple exits!

        $a = $b = false;

		// It's possible that we don't even want to compare this data

        if (in_array($row, $this->omit))
            return;

		// A bit of shorthand

        if (isset($this->da[$row]))
            $a = $this->da[$row];

        if (isset($this->db[$row]))
            $b = $this->db[$row];

		// Is there any data to compare? if not, let's go.

		if (!$a && !$b)
			return;

		// Some fields have special functions which we use to compare them.
		// The rest use the compare_generic() method. Work out what that
		// method should be called, see if it exists, and call

		$method = preg_replace("/\s/", "_", "compare_$row");

		$fields = (method_exists($this, $method))
			? $this->$method($row, $a, $b)
			: $this->compare_generic($row, $a, $b);

		$class = (preg_match("/colspan/", $fields))
			? "solidgreen"
			: "solidred";

		return ($fields)
			? "\n<tr class=\"server\"><td class=\"$class\" "
			. "width=\"20%\">$row</td>$fields</tr>"
			: false;
    }

    public function compare_generic($row, $a, $b)
    {
		// Generic comparison function. Colours the highest numbered field
		// green and the lowest red, unless the row we're studying is in the
		// no_cols[] array

		// If we've been given arrays with multiple elements, pass lists to
		// the compare_lists() function

        if (sizeof($a) > 1 || sizeof($b) > 1) {
            $ret = $this->compare_lists($row, $a, $b);
        }
        else {

			// We have single element arrays. Convert them to strings, trim
			// them, and if we're left with just a "-", set it to a blank
			// string

            $a = trim($a[0]);
            $b = trim($b[0]);

            // Do nothing if both fields are empty strings

            if ($a == "" && $b == "")
                $ret = false;

			// If both strings are the same, put them in a green box

            elseif ($a == $b) {
				$ret = $this->show_col($row, array($a), 2);
            }
            else {

				// Unless we've been asked not to, compare $a and $b. 
				// Colour the larger number green and the smaller red.
				// Because we're dealing with funny version numbers, a
				// direct "<" comparison can't be trusted

                if (!in_array($row, $this->no_col) && $a != "" && $b != "") {

                    if ($this->safe_compare($a, $b)) {
                        $lcol = "solidgreen";
                        $rcol = "solidred";
                    }
                    else {
                        $lcol = "solidred";
                        $rcol = "solidgreen";
                    }

                }
                else
                    $lcol = $rcol = false;

                $ret = new Cell($a, $lcol) .  new Cell($b, $rcol);
            }

        }

        return $ret;
    }

	private function show_col($row, $data, $span = false)
	{
		// Use the show_ functions to present data

		$method = "show_$row";

		if ($span) {

			$ret = (method_exists($this, $method))
				? preg_replace("/<td/", "<td colspan=\"2\"", 
				$this->$method($data))
				: new listCell($data, false, 2);
			
		}
		else {

			$ret = (method_exists($this, $method))
				? $this->$method($data)
				: new listCell($data);
		}

		return $ret;

	}

    protected function compare_lists($row, $a, $b, $fn = false)
    {
        // Compare lists of things on two servers. This is a simplified
        // version of compare_patch. See that function for comments.

        if (!is_array($a))
            $a = array();

        if (!is_array($b))
            $b = array();

        if ($a == $b) {
			$ret = $this->show_col($row, $a, 2);
        }
        else {
            $diffed_a = array_diff($a, $b);
            $diffed_b = array_diff($b, $a);
            $combined = array_merge($diffed_a, $diffed_b);
            sort($combined);

            $col_a = $col_b = "\n<ul>";

            $i = 1;
            $rows = sizeof($combined);

            foreach($combined as $element) {

                $prt = $element;

                if ($fn)
                    $prt = $this->$fn($prt);

                $col_a .= "\n  <li>";
                $col_b .= "\n  <li>";

                // It's in one list or the other. Otherwise, we wouldn't be
                // here

                if (in_array($element, $diffed_a)) {
                    $col_a .= $prt;
                    $col_b .= "&nbsp;";
                }
                else {
                    $col_a .= "&nbsp";
                    $col_b .= $prt;
                }

                $col_a .= "</li>";
                $col_b .= "</li>";

            }
            $ret = new Cell("${col_a}\n</ul>") . new
            Cell("${col_b}\n</ul>");
        }

        return $ret;
    }

	public function __toString()
	{
		return $this->html;
	}

}

class comparePlatform extends compareGeneric{
	
	protected $no_col = array("hardware", "CPU", "serial number", "ALOM
	IP");

	protected $hw_db;   // Card definitions from defs.php

    public function __construct($map, $data_a, $data_b)
    {
        // We need the card definitions in defs.php

        require_once(LIB . "/defs.php");
        $defs = new defs();
        $this->card_db = $defs->get_data("card_db");
        $this->hw_db = $defs->get_data("hw_db");

        parent::__construct($map, $data_a, $data_b);
    }

}

class compareOS extends compareGeneric{
	
	protected $no_col = array("hostid", "uptime");
}

class compareNet extends compareGeneric{
	
	protected $no_col = array("NIC");
}


/*

    protected function compare_uptime($row, $a, $b, $fn = false)
	{
		// Use the display function to make uptime nicely human-readable

		return $this->show_uptime($a) . $this->show_uptime($b);
	}

	protected function compare_fs($row, $a, $b)
	{
		$ao = $bo = array();

		if (is_array($a)) {
			sort($a);

			foreach ($a as $el) {
				$z = preg_split("/\s+/", $el, 2);
				$ao[] = "<div><strong>$z[0]</strong></div><div>$z[1]</div>";
			}

		}
		
		if (is_array($b)) {
			sort($b);

			foreach ($b as $el) {
				$z = preg_split("/\s/", $el, 2);
				$bo[] = "<div><strong>$z[0]</strong></div><div>$z[1]</div>";
			}

		}

		return new multicell($ao, "smallrow") . new multicell($bo, "smallrow");
	}

	public function compare_local_zone($row, $a, $b)
	{
		// Compare zones. Just sort the lists and print them side by side,
		// with a bit of nice formatting. Also works for LDOMs.

		$ao = $bo = array();

		if (is_array($a)) {
			sort($a);

			foreach ($a as $el) {
				$z = preg_split("/\s+/", $el, 3);
				$ao[] = "<div><strong>$z[0]</strong></div><div>$z[1]</div>"
				. "<div>$z[2]</div>";
			}

		}
		
		if (is_array($b)) {
			sort($b);

			foreach ($b as $el) {
				$z = preg_split("/\s/", $el, 3);
				$bo[] = "<div><strong>$z[0]</strong></div><div>$z[1]</div>"
				. "<div>$z[2]</div>";
			}

		}

		return new multicell($ao, "smallrow") . new multicell($bo, "smallrow");
	}

	protected function compare_ldom($row, $a, $b)
	{
		// I refer you to compare_zone();

		return $this->compare_local_zone($row, $a, $b);
	}

    protected function $ret["a"] .= new Cell($a_prt, $myclass);
                $ret["b"] .= new Cell("&nbsp;", $myclass);
            }
            elseif($b) {
                $ret["a"] .= new Cell("&nbsp;", $myclass);
                $ret["b"] .= new Cell($b_prt, $myclass);
            }

            $ret["a"] .= "</tr>";
            $ret["b"] .= "</tr>";
        }

        return $ret;

    }

    protected function package_link($name)
    {
        // Make a chunk of HTML to have little mouseover descriptions of
        // package names. Requires the pkg_defs.php file, which must be
        // generated on cs-build-01

        global $pkgdefs;

        $tip = "unknown package";

        if (isset($pkgdefs)) {

            if (isset($pkgdefs[$name])) {
                $tip = $pkgdefs[$name];
            }

        }

        return "<div title=\"$tip\">$name</div>";
    }

    protected function patch_link($prt)
    {
        // Turns patch numbers into clickable links to sunsolve

        return "<a href=\"http://sunsolve.sun.com/search/document.do"
        . "?assetkey=1-21-${prt}-1\">$prt</a>";
    }

    protected function compare_database($row, $a, $b)
	{
		// Just format a list of databases.

        return $this->compare_trimmed_lists($row, $a, $b);
    }

    protected function compare_website($row, $a, $b)
	{
		// Just format a list of sites.

        return $this->compare_trimmed_lists($row, $a, $b);
    }

    protected function compare_trimmed_lists($row, $a, $b)
    {
        // Strip off all extraneous data and pass what's left (after
        // removing duplicates) to the compare_lists function

        $call_a = $call_b = array();

        if (!is_array($a))
            $a = array();

        if (!is_array($b))
            $b = array();

        foreach($a as $el)
            $call_a[] = preg_replace("/ .*$/", "", $el);

        foreach($b as $el)
            $call_b[] = preg_replace("/ .*$/", "", $el);

        return $this->compare_lists($row, array_unique($call_a),
        array_unique($call_b));
    }

    protected function compare_package($row, $a, $b)
    {
        return $this->compare_lists($row, $a, $b, "package_link");
    }

*/

?>
