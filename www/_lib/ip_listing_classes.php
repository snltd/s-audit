<?php

//============================================================================
//
// ip_listing_classes.php
// ----------------------
//
// Classes used in the IP listing page
//
// R Fisher
//
// Please record changes below.
//
// v1.0  Initial release
//
// v1.1  Changed to work with hardware audit instead of platform, and new
//       NIC list format. Changed eregs to pregs. Made much more
//       fault-tolerant. 09/12/09 RDF
//
// v1.2  Works with new colour-coding classes. RDF 11/02/10
//
//============================================================================

//----------------------------------------------------------------------------
// DATA COLLECTION

class GetIPAddrsAudits {

	// This class gets an array of IP addresses from the audit files.
	
	protected $file_list;
	protected $ip_addrs = array();	// array e.g. [1.2.3.4]=>"my-server"
	protected $networks = array();	// array

	public function __construct($map)
	{
		// Call the constructor with a map generated by instantiating the
		// ZoneFileMap class

		// No point continuing if we're looking at an empty directory.

		if (sizeof($map->map) == 0)
			return;

		// Build up a list of all the IP addresses mentioned in all the
		// hardware audit files. First, get a list of all the hardware files
		// we have.

		foreach ($map->list_globals() as $zone) {
			$hw_file = $map->get_base($zone) . ".hardware";

			if (file_exists($hw_file))
				$this->file_list[] = $hw_file;
		}
		
		if (sizeof($this->file_list) == 0)
			return;

		foreach($this->file_list as $hw_file) {

			// Get all the NIC and ALOM IP entries from the file list we
			// just made.

			$nic_arr = $this->get_value($hw_file, "NIC");

			// Also look for LOMs. Pull those out and make them into lines
			// which look like NIC lines. (That way I don't have to rewrite
			// the NIC line handling code below.)

			if ($lom_arr = $this->get_value($hw_file, "ALOM IP"))
				$nic_arr[] = "alom|" . trim($lom_arr[0]) . "||||";


			// The nic lines are "|" separated fields. The IP address is the
			// second field, and we only want to examine those.

			$nic_arr =
			preg_grep("/^[^\|]*\|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\|/",
			$nic_arr);

			foreach($nic_arr as $nic) {
				$na = explode("|", $nic);
			
				$this->ip_addrs[$na[1]] = $na[2];
				$this->update_subnet_list($na[1]);
			}
			
		}

	}

	protected function update_subnet_list($addr)
	{
		// Pass this all the IP addresses you encounter, and it will build
		// up a list of unique subnets in $this->networks

		$network = preg_replace("/.\d+\s*$/", "", $addr);

		if (!in_array($network, $this->networks))
			$this->networks[] = $network;

	}

	public function get_addrs()
	{
		return $this->ip_addrs;
	}

	public function get_networks()
	{
		sort($this->networks);
		return $this->networks;
	}

	private function get_value($file, $key)
	{
		// Get the value paired with key in the named file. Returns values
		// as an array

		$ret_arr = array();

		$file_pointer = fopen("$file", "r");

		for ($i = 0; !feof($file_pointer); $i++) {
			$line = fgets($file_pointer, 1024);

			if (preg_match("/^${key}=/", $line))
				$ret_arr[] = preg_replace("/^${key}=/", "", $line);
		}

		return $ret_arr;
	}

}

class GetIPAddrsIPList extends GetIPAddrsAudits {

	// This class reads and parses IP address map generated by the
	// becta_subnet_audit.sh script in the Subversion support/ directory. It
	// used to create arrays identical to GetIPAddrsAudits, but since we
	// moved to the becta_subnet_audit.sh script from nmap, there's more
	// information to deal with, so things are slightly different. There's
	// still a $networks array, but rather than the single $ip_addrs array,
	// this class's get_addr() function returns an array with elements
	// $ip_addr_p and $ip_addr_r, which are pingable and resolvable lists
	// respectively

	private $eng_time;
		// A formatted string saying when the IP map was created
	
	private $timestamp;
		// A string telling us which host produced the IP map

	private $ip_addr_p = array();
	private $ip_addr_r = array();

	// $file is the path to the IP address map file

	public function __construct($file)
	{
		// The constructor is called with the path to the IP address map
		// file as its sole argument, and it populates an array $networks,
		// of the form
		//    numeric_address->hostname
		//
		// This is identical to the networks array produced by
		// GetIPAddrsAudits. 

		global $pg;

		if (!file_exists($file))
			$pg->error("Cannot find IP listing file [${file}]");

		$in = file($file);

		// The first line of the file should be of the form
		//    @@ hostname time date

		if (!preg_match("/^@@ /", $in[0]))
			$pg->error("IP listing file is in wrong format.");

		// Parse the header and store what we find, then throw away the
		// header

		$head = explode(" ", $in[0]);
		$this->timestamp = "$head[2] on $head[3]";
		$this->scan_host = $head[1];
		unset($in[0]);

		// The rest of the file is of the form:
		// ip_address hostname ip_address
		// separator is a space, "blank" fields are denoted by "-"

		// Make two arrays. The first is "pingable" addresses, and is just a
		// list of live IP addresses. The second array is of the form
		// address=>hostname, and is "resolved"

		foreach($in as $addr) {
			$e = explode(" ", $addr);

			if ($e[0] != "-") {
				$this->ip_addr_p[] = trim($e[0]);
				$addr = $e[0];
			}

			if ($e[1] != "-" && $e[2] != "-") {
				$this->ip_addr_r[trim($e[2])] = trim($e[1]);
				$addr = $e[2];
			}

			$this->update_subnet_list($addr);
		}

	}

	public function get_timestamp()
	{
		return $this->timestamp;
	}

	public function get_scan_host()
	{
		return $this->scan_host;
	}

	public function get_addrs()
	{
		return array
			("ip_addr_p" => $this->ip_addr_p,
			"ip_addr_r" => $this->ip_addr_r);
	}

}

class GetIPAddrsReserved extends GetIPAddrsAudits {

	// This class reads and parses a "hand-made" IP address map. You can use
	// this to store things like ranges of DHCP addresses, or laptop IPs
	// which, thought they may not be active when scans or audits are
	// performed, should not be listed as available for use.

	public function __construct($file)
	{
		// The works just like the one in GetIPAddrsIPList

		foreach (file($file) as $l) {
			// Disregard lines which don't look roughly correct. They should
			// be of the form "ip_address hostname", space separated

			if (preg_match("/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\s+\S+$/",
			$l)) {
				$e = preg_split("/\s+/", $l);
				$this->ip_addrs[$e[0]] = trim($e[1]);
				$this->update_subnet_list($e[0]);
			}

		}
		
		// Make the last update time of the file available
		$ts = filemtime($file);

		$this->timestamp = date("H:i", $ts) . " on " . date("d/m/Y");
	}

	public function get_timestamp()
	{
		return $this->timestamp;
	}

}

//----------------------------------------------------------------------------
// DATA DISPLAY

class IPGrid extends HostGrid{

	// This class creates the HTML for the IP address audit. A column for
	// each known subnet, and lots of colour-coding.

    public $show_count = false;
		// Server count doesn't make sense in this context

	protected $fields;	// array of networks
	private $rows;		// array 1-255

	private $r_list = array();	// resolvable ip_address->hostname from
								// subnet scan
	private $p_list = array();	// live ip_address from subnet scan
	private $l_list = array();	// ip_address->hostname from live audits
	private $o_list = array();	// ip_address->hostname from obsolete audits
	private $h_list = array();	// ip_address->hostname from reserved list

	private $live_servers;	// list of live servers

	public function __construct($cols, $s_list, $l_list, $o_list, $h_list)
	{
		// We may have an empty s_list, if the audit file's not there.

		if (sizeof($s_list) > 0) {
			$this->r_list = $s_list["ip_addr_r"];
			$this->p_list = $s_list["ip_addr_p"];
		}

		$this->l_list = $l_list;
		$this->o_list = $o_list;
		$this->h_list = $h_list;

		// Rows and columns. The cols are the subnets we know about

		$this->fields = $cols;

		// And the rows are 1-255

		for ($i = 1; $i < 256; $i++)
			$this->rows[$i] = $i;

		// get a list of the live servers

		$map = new ZoneFileMap(LIVE_DIR);
		$this->live_servers = $this->map = $map->list_all();
	}

	public function grid_header()
	{
		// Print the horizontal table column headers. Override the default
		// method because we force each column to be the same width
	
		$ret_str = "\n<tr>";
		$w = 100 / sizeof($this->fields);
	
		foreach($this->fields as $field)
			$ret_str .= "<th width=\"${w}%\" >$field</th>";
	
		return $ret_str . "</tr>";
	}

	public function grid_body()
	{
		$ret = "";

		// Working along the rows -- i.e. the 1-255 address number

		foreach($this->rows as $row) {
			$ret .= "\n<tr>";

			// Working along the colunmns -- i.e. the subnets

			foreach($this->fields as $network) {
				$addr = "${network}.$row";
				unset($matched);

				// Look at the scan, live, obsolete, ping, and reserved
				// lists in turn, seeing if any of them have this IP
				// address. Note the order of precedence.

				// In the subnet audit, pingable and resolved

				if (in_array($addr, array_keys($this->r_list))) {
					$ret .= $this->disp_ip($addr, $this->r_list[$addr],
					"resolved");
				}

				// in the live audit files

				elseif (in_array($addr, array_keys($this->l_list))) {
					$ret .= $this->disp_ip($addr, $this->l_list[$addr],
					"onlylive");
				}
				
				// in the obsolete audit files

				elseif (in_array($addr, array_keys($this->o_list))) {
					$ret .= $this->disp_ip($addr, $this->o_list[$addr],
					"obsolete");
				}

				// in the reserved list

				elseif (in_array($addr, array_keys($this->h_list))) {
					$ret .= $this->disp_ip($addr, $this->h_list[$addr],
					"reserved");
				}

				// in the subnet audit, but only pinged, didn't resolve

				elseif (in_array($addr, $this->p_list)) {
					$ret .= $this->disp_ip($addr, "unknown", "ping");
				}

				// must be free then

				else {
					$ret .= new Cell($addr, "ip_free");
				}
			}

			$ret .= "</tr>";

		}

		return $ret;
	}

	private function disp_ip($addr, $hostname, $class) {
		
		// Work out exactly how to display information for the address and
		// hostname supplied as args

		// Do a bit of hostname massaging. We may be required to strip the
		// domain name off, or we may have to fill in "uknown host"

		$h = trim($hostname);

		if ($h == "")
			$h = "unknown host";
		elseif (STRIP_DOMAIN)
			$h = preg_replace("/." . STRIP_DOMAIN . "/", "", $h);

		// Make zones known to the auditor bold. Might put linkage here at
		// some point

		if (in_array($h, $this->live_servers))
			$h = "<strong>$h</strong>";

		// Does the IP address exist in the ping list? If it does, give it a
		// green border to show we've checked it and it's live. If not, give
		// it a red border, and colour the cell accordingly.

		if (in_array($addr, $this->p_list))
			$border = inlineCol::box("green");
		else {
			$border = inlineCol::box("red");

			if ($class == "resolved")
				$class = "onlyresolve";
			elseif ($class == "live")
				$class = "onlylive";
		}

		return new Cell("$addr ($h)", $class, $border);
	}

}

?>
